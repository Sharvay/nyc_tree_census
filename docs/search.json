[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "NYC Tree Census",
    "section": "",
    "text": "1 Introduction\nTrees are essential to urban ecosystems, providing critical benefits such as air purification, temperature regulation, storm-water management, and enhanced biodiversity. Their canopies mitigate the urban heat island effect, reduce energy consumption, and offer habitats for wildlife while improving mental well-being and fostering community cohesion. Recognizing these contributions, this project leverages NYC’s 2015 tree census data, a comprehensive inventory of over 666,000 street trees, to analyze their distribution, health, and impact. The dataset serves as a foundation for assessing the state of the urban forest, identifying areas for improvement, and developing strategies for sustainable urban forestry management.\n\nExpected Outcomes: Key Areas of Exploration\nThis extensive dataset serves as a critical resource for understanding the composition and condition of New York City’s urban forest. This dataset provides a unique opportunity to explore several key areas:\n\nTree Health and Environmental Impact:\nInvestigate factors affecting tree health and their relationship to size and location.\nInfrastructure Interaction:\nExplore the impact of tree placement on sidewalk damage and other infrastructure issues.\nCommunity Engagement:\nAssess how Stewardship activities influence tree health and urban forestry.\nUrban Planning and Spatial Trends:\nAnalyze tree distribution and species diversity across boroughs and neighborhoods.\nTree Vulnerability:\nIdentify common issues affecting tree trunks, branches, and roots, and their locations.\nBiodiversity Analysis:\nEvaluate the diversity of NYC’s tree population and its implications for urban forestry.\nTemporal Insights:\nExamine patterns in tree mapping and their significance for urban forest management.\nClimate Adaptation:\nDetermine which tree species are best suited for NYC’s urban environment.\n\nOur project aims to analyze these aspects, leveraging this rich dataset to derive actionable insights for urban forestry management",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "data.html",
    "href": "data.html",
    "title": "2  Data",
    "section": "",
    "text": "2.1 Description\nThe “2015 Street Tree Census - Tree Data” dataset is a comprehensive collection of information on New York City’s street trees, compiled by the NYC Department of Parks & Recreation in collaboration with volunteers and partner organizations between May 2015 and October 2016. Representing the largest citizen science initiative in the city’s history, the dataset includes detailed attributes for 666,134 recorded trees across New York City’s five boroughs.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data</span>"
    ]
  },
  {
    "objectID": "data.html#description",
    "href": "data.html#description",
    "title": "2  Data",
    "section": "",
    "text": "Source : 2015 Street Tree Census - Tree Data\nData Collection :\nThe data was collected by trained volunteers and NYC Parks staff, using standardized protocols to ensure consistency. Each tree’s attributes, including species, diameter, health status, and geographic location, were recorded during the census. The data collection process also involved visual inspections and field surveys to gather accurate information on tree conditions and their interactions with surrounding infrastructure.\nData Format and Structure:\nThe data is presented in a tabular format, with each row representing an individual tree and columns detailing its attributes. Key attributes include:\n\nTree Identification : Unique Tree ID and Block ID for each tree.\n\nSpecies Information : Scientific (Latin) and common names of the tree species.\n\nPhysical Characteristics : Diameter at Breast Height (DBH), health status (Good, Fair, Poor, Dead), and presence of root guards. Assessment of trunk, branch.\nLocation Details : Geographic coordinates (latitude and longitude), nearest address, borough, and community board.\n\nStewardship and Infrastructure : Level of care provided, sidewalk details, and curb location.\n\nDimensions and Scope:\nThe dataset comprises 666,134 records and 45 columns, each corresponding to an individual street tree. It offers a rich combination of categorical and numerical variables suitable for diverse analytical approaches. Its spatial information enables geospatial analyses, such as examining tree distribution patterns across neighborhoods and boroughs. This richness makes the dataset particularly well-suited for exploratory data analysis, allowing us to uncover trends and insights relevant to urban forestry management.\nFrequency of Update :\nThe dataset is static, representing a one-time snapshot of the NYC street trees as they existed during the census period (2015–2016). It does not receive updates and serves as a historical record.\nImport Methodology :\nThe dataset will be imported using R’s read.csv() function to handle its large size efficiently.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data</span>"
    ]
  },
  {
    "objectID": "data.html#missing-value-analysis",
    "href": "data.html#missing-value-analysis",
    "title": "2  Data",
    "section": "2.2 Missing value analysis",
    "text": "2.2 Missing value analysis\n\n2.2.1 R Code\n\n\nCode\n# Library Imports\nlibrary(tidyverse)  \n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nCode\nlibrary(readr)      \nlibrary(ggplot2)    \nlibrary(dplyr)\n\n\n\n\nCode\ntree_data &lt;- read_csv(\"../2015_Street_Tree_Census_-_Tree_Data_20241120.csv\")\n\n\nRows: 683788 Columns: 45\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (26): created_at, curb_loc, status, health, spc_latin, spc_common, stewa...\ndbl (19): tree_id, block_id, tree_dbh, stump_diam, postcode, community board...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nCode\ntree_data |&gt;\n  summarise(across(everything(), ~ sum(is.na(.) | . == \"\" | . == \"None\")))\n\n\n# A tibble: 1 × 45\n  tree_id block_id created_at tree_dbh stump_diam curb_loc status health\n    &lt;int&gt;    &lt;int&gt;      &lt;int&gt;    &lt;int&gt;      &lt;int&gt;    &lt;int&gt;  &lt;int&gt;  &lt;int&gt;\n1       0        0          0        0          0        0      0  31616\n# ℹ 37 more variables: spc_latin &lt;int&gt;, spc_common &lt;int&gt;, steward &lt;int&gt;,\n#   guards &lt;int&gt;, sidewalk &lt;int&gt;, user_type &lt;int&gt;, problems &lt;int&gt;,\n#   root_stone &lt;int&gt;, root_grate &lt;int&gt;, root_other &lt;int&gt;, trunk_wire &lt;int&gt;,\n#   trnk_light &lt;int&gt;, trnk_other &lt;int&gt;, brch_light &lt;int&gt;, brch_shoe &lt;int&gt;,\n#   brch_other &lt;int&gt;, address &lt;int&gt;, postcode &lt;int&gt;, zip_city &lt;int&gt;,\n#   `community board` &lt;int&gt;, borocode &lt;int&gt;, borough &lt;int&gt;, cncldist &lt;int&gt;,\n#   st_assem &lt;int&gt;, st_senate &lt;int&gt;, nta &lt;int&gt;, nta_name &lt;int&gt;, …\n\n\n\n\nCode\ntree_data_with_na &lt;- tree_data |&gt;\n  mutate(across(everything(), ~ ifelse(is.na(.) | . == \"\" | . == \" \" | . == \"None\", NA, .)))\n\n\n\n\nCode\n# Step 1: Count NA values in each column\nna_counts &lt;- tree_data_with_na %&gt;%\n  summarise(across(everything(), ~ sum(is.na(.)))) %&gt;%\n  t() %&gt;%\n  as.data.frame()\n\n# Add column names for clarity\ncolnames(na_counts) &lt;- c(\"NA_Count\")\nna_counts$Column &lt;- rownames(na_counts)\nrownames(na_counts) &lt;- NULL\n\n# Step 2: Calculate total rows and convert counts to percentages\ntotal_rows &lt;- nrow(tree_data)\nna_counts &lt;- na_counts %&gt;%\n  mutate(Percentage = (NA_Count / total_rows) * 100)\n\n# Step 3: Filter out columns with no NA values\nna_counts_filtered &lt;- na_counts %&gt;%\n  filter(NA_Count &gt; 0)\n\n# Step 4: Plot NA percentages for remaining columns\nggplot(na_counts_filtered, aes(x = reorder(Column, -Percentage), y = Percentage)) +\n  geom_bar(stat = \"identity\", fill = \"steelblue\", color = \"black\", width = 0.7) +\n  geom_text(aes(label = paste0(round(Percentage, 1), \"%\")), \n            vjust = -0.5, size = 4, color = \"black\") +\n  theme_minimal() +\n  labs(\n    title = \"Percentage of Missing Values in Columns with NA Values\",\n    x = \"Columns\",\n    y = \"Percentage of Missing Values\"\n  ) +\n  scale_y_continuous(labels = scales::percent_format(scale = 1)) +\n  theme(\n    plot.title = element_text(hjust = 0.5, size = 14, face = \"bold\"),\n    axis.text.x = element_text(angle = 45, hjust = 1, size = 10),\n    axis.text.y = element_text(size = 10),\n    axis.title.x = element_text(size = 12, face = \"bold\"),\n    axis.title.y = element_text(size = 12, face = \"bold\")\n  )\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Step 1: Convert all columns to character type (except row identifier)\ntree_data_char &lt;- tree_data_with_na %&gt;%\n  mutate(across(everything(), as.character))\n\n# Step 2: Add a row identifier\ntree_data_char &lt;- tree_data_char %&gt;%\n  mutate(row = row_number())\n\n# Step 3: Reshape data into long format, excluding the `row` column\nna_heatmap_data &lt;- tree_data_char %&gt;%\n  pivot_longer(cols = -row, names_to = \"Column\", values_to = \"Value\") %&gt;%\n  mutate(Missing = is.na(Value) | Value == \"\" | Value == \"None\")  # Detect missing values\n\n# Step 4: Plot the heatmap\nggplot(na_heatmap_data, aes(x = Column, y = row, fill = Missing)) +\n  geom_tile() +\n  scale_fill_manual(values = c(\"TRUE\" = \"red\", \"FALSE\" = \"white\")) +\n  theme_minimal() +\n  labs(\n    title = \"Heatmap of Missing Values\",\n    x = \"Columns\",\n    y = \"Rows\",\n    fill = \"Missing\"\n  ) +\n  theme(\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    axis.text.y = element_blank(),\n    plot.title = element_text(hjust = 0.5)\n  )\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Step 1: Convert all columns to character type (except row identifier)\ntree_data_char &lt;- tree_data_with_na %&gt;%\n  mutate(across(everything(), as.character))\n\n# Step 2: Identify columns with NA values\ncolumns_with_na &lt;- tree_data_char %&gt;%\n  summarise(across(everything(), ~ sum(is.na(.) | . == \"\" | . == \"None\"))) %&gt;%\n  select(where(~ . &gt; 0)) %&gt;%\n  names()\n\n# Step 3: Filter to include only columns with NA values and add row identifier\ntree_data_filtered &lt;- tree_data_char %&gt;%\n  select(all_of(columns_with_na)) %&gt;%\n  mutate(row = row_number())\n\n# Step 4: Reshape data into long format, excluding the `row` column\nna_heatmap_data &lt;- tree_data_filtered %&gt;%\n  pivot_longer(cols = -row, names_to = \"Column\", values_to = \"Value\") %&gt;%\n  mutate(Missing = is.na(Value) | Value == \"\" | Value == \"None\")  # Detect missing values\n\n# Step 5: Plot the heatmap\nggplot(na_heatmap_data, aes(x = Column, y = row, fill = Missing)) +\n  geom_tile() +\n  scale_fill_manual(values = c(\"TRUE\" = \"red\", \"FALSE\" = \"white\")) +\n  theme_minimal() +\n  labs(\n    title = \"Heatmap of Missing Values (Columns with NA Values Only)\",\n    x = \"Columns\",\n    y = \"Rows\",\n    fill = \"Missing\"\n  ) +\n  theme(\n    axis.text.x = element_text(angle = 45, hjust = 1),\n    axis.text.y = element_blank(),\n    plot.title = element_text(hjust = 0.5)\n  )\n\n\n\n\n\n\n\n\n\n\n\n2.2.2 High Missing Value Columns\n\nguards: With 88.3% missing values, this column has the highest rate of missingness. The data on tree guards might not have been consistently collected, possibly because it was optional or difficult to assess during the survey.\nsteward: At 76% missing values, this column reflects limited data availability on tree stewardship. This may be due to a lack of reporting or complexity in identifying individuals or groups responsible for tree care.\nproblems: This column has 67% missing values. It indicates incomplete data on issues affecting the trees, which could result from challenges in identifying or documenting tree-related problems.\n\n\n\n\n2.2.3 Low Missing Value Columns\n\nColumns like spc_common, spc_latin, health, and sidewalk: These columns have around 4.6% missing values. These fields likely had better data collection protocols but still show gaps, potentially due to oversight or difficulty in identifying specific attributes (e.g., species or tree health conditions).\nbbl, bin, census tract, and council district: These columns exhibit very low missing values (less than 2%). These administrative or geographic fields were likely easier to document consistently, but small gaps might have occurred due to technical issues or incomplete records.\n\n\n\n\n2.2.4 Columns with No Missing Values\n\nMany columns in the dataset have no missing values, which indicates robust data collection for these fields. These complete columns will form a reliable foundation for further analysis.\n\n\n\n\n2.2.5 Nature of Missing Values\nThe dataset contains missing values in various non-uniform forms. Some values are represented as standard NA in R, while others are explicitly recorded as \"None\". Additionally, there are instances where missing values are represented as blank strings (\"\") or blank spaces (\" \"). This lack of uniformity highlights inconsistencies in data recording, likely stemming from variations in surveyor practices or data entry protocols.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Data</span>"
    ]
  }
]